// lib/hunterMedia.ts - Complete version with all types
import ExifReader from 'exifreader'

// EXIF Data Types - matching ExifReader's actual output format
export interface ExifData {
  DateTime?: {
    description: string
    value?: any
  }
  DateTimeOriginal?: {
    description: string
    value?: any
  }
  DateTimeDigitized?: {
    description: string
    value?: any
  }
  GPSLatitude?: {
    description: string
    value?: any
  }
  GPSLongitude?: {
    description: string
    value?: any
  }
  GPSLatitudeRef?: {
    description: string
    value?: any
  }
  GPSLongitudeRef?: {
    description: string
    value?: any
  }
  Make?: {
    description: string
    value?: any
  }
  Model?: {
    description: string
    value?: any
  }
  Orientation?: {
    description: string
    value?: any
  }
  XResolution?: {
    description: string
    value?: any
  }
  YResolution?: {
    description: string
    value?: any
  }
  [key: string]: any
}

// Core Media Types
export interface MediaFile {
  id: number
  filename: string
  file_path: string
  media_type: 'image' | 'video'
  file_size?: number
  taken_at?: string
  location_lat?: number
  location_lng?: number
  location_name?: string
  description?: string
  created_at: string
  
  // Thumbnail paths (generated by the system)
  thumbnail_150?: string
  thumbnail_500?: string
  thumbnail_1200?: string
  
  // Tags relationship
  tags?: Array<{
    id: number
    tag_type: string
    tag_value: string
    value: string // For backward compatibility
  }>
  
  // Computed properties
  has_location?: boolean
}

export interface MediaTag {
  id: number
  media_id: number
  tag_type: string
  tag_value: string
}

export interface SearchFilters {
  search?: string
  startDate?: string
  endDate?: string
  location?: string
  tags?: string[]
  type?: 'image' | 'video'
  limit?: number | string  // Added limit property
}

export interface MediaResponse {
  media: MediaFile[]
  total: number
  hasMore: boolean
  filters: SearchFilters
}

// EXIF Processing Types
export interface ProcessedExifData {
  dateTime?: Date
  latitude?: number
  longitude?: number
  camera?: string
  orientation?: number
}

// Utility Functions
export function extractExifData(buffer: ArrayBuffer): ProcessedExifData {
  try {
    // ExifReader expects ArrayBuffer or Uint8Array
    const tags = ExifReader.load(buffer) as any
    const result: ProcessedExifData = {}

    // Extract date/time
    const dateTimeOriginal = tags.DateTimeOriginal || tags.DateTime || tags.DateTimeDigitized
    if (dateTimeOriginal && dateTimeOriginal.description) {
      try {
        // EXIF date format: "YYYY:MM:DD HH:mm:ss"
        const dateStr = dateTimeOriginal.description.replace(/^(\d{4}):(\d{2}):(\d{2})/, '$1-$2-$3')
        result.dateTime = new Date(dateStr)
      } catch (e) {
        console.warn('Could not parse EXIF date:', dateTimeOriginal.description)
      }
    }

    // Extract GPS coordinates
    if (tags.GPSLatitude && tags.GPSLongitude) {
      try {
        let lat: number | undefined
        let lng: number | undefined

        // Handle different formats from ExifReader
        if (typeof tags.GPSLatitude.value === 'number') {
          lat = tags.GPSLatitude.value
        } else if (typeof tags.GPSLatitude.description === 'string') {
          lat = parseFloat(tags.GPSLatitude.description)
        }

        if (typeof tags.GPSLongitude.value === 'number') {
          lng = tags.GPSLongitude.value
        } else if (typeof tags.GPSLongitude.description === 'string') {
          lng = parseFloat(tags.GPSLongitude.description)
        }

        // Apply hemisphere corrections
        if (tags.GPSLatitudeRef && tags.GPSLatitudeRef.description === 'S' && lat) {
          lat = -Math.abs(lat)
        }
        if (tags.GPSLongitudeRef && tags.GPSLongitudeRef.description === 'W' && lng) {
          lng = -Math.abs(lng)
        }

        if (typeof lat === 'number' && typeof lng === 'number' && 
            !isNaN(lat) && !isNaN(lng) && 
            lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
          result.latitude = lat
          result.longitude = lng
        }
      } catch (e) {
        console.warn('Could not parse GPS coordinates:', e)
      }
    }

    // Extract camera info
    const make = tags.Make?.description
    const model = tags.Model?.description
    if (make || model) {
      result.camera = [make, model].filter(Boolean).join(' ')
    }

    // Extract orientation
    if (tags.Orientation) {
      const orientation = tags.Orientation.value || tags.Orientation.description
      if (typeof orientation === 'number') {
        result.orientation = orientation
      } else if (typeof orientation === 'string') {
        const parsed = parseInt(orientation, 10)
        if (!isNaN(parsed)) {
          result.orientation = parsed
        }
      }
    }

    return result
  } catch (error) {
    console.error('Error extracting EXIF data:', error)
    return {}
  }
}

export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 Bytes'
  
  const k = 1024
  const sizes = ['Bytes', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
}

export function getLocationName(lat: number, lng: number): Promise<string | null> {
  // This would typically use a reverse geocoding service
  // For now, return a placeholder
  return Promise.resolve(`${lat.toFixed(4)}, ${lng.toFixed(4)}`)
}

// Tag-related utilities
export const TAG_TYPES = {
  PERSON: 'person',
  DOG: 'dog', 
  ACTIVITY: 'activity',
  LOCATION: 'location',
  EVENT: 'event',
  MOOD: 'mood'
} as const

export type TagType = typeof TAG_TYPES[keyof typeof TAG_TYPES]

export function createTag(mediaId: number, tagType: TagType, tagValue: string): Omit<MediaTag, 'id'> {
  return {
    media_id: mediaId,
    tag_type: tagType,
    tag_value: tagValue.trim().toLowerCase()
  }
}

// Database functionality
import { Pool } from 'pg'

// Initialize database connection
let pool: Pool | null = null

export function getPool(): Pool {
  if (!pool) {
    pool = new Pool({
      connectionString: process.env.DATABASE_URL || process.env.POSTGRES_URL,
      ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
    })
  }
  return pool
}

// Database operations
export async function saveMediaFile(
  filename: string,
  filePath: string,
  mediaType: 'image' | 'video',
  fileSize: number,
  exifData: ProcessedExifData
): Promise<MediaFile> {
  const pool = getPool()
  
  const query = `
    INSERT INTO hunter_memorial.hunter_media 
    (filename, file_path, media_type, file_size, taken_at, location_lat, location_lng)
    VALUES ($1, $2, $3, $4, $5, $6, $7)
    RETURNING *
  `
  
  const values = [
    filename,
    filePath,
    mediaType,
    fileSize,
    exifData.dateTime || null,
    exifData.latitude || null,
    exifData.longitude || null
  ]
  
  const result = await pool.query(query, values)
  return result.rows[0]
}

export async function getMediaFiles(filters: SearchFilters = {}): Promise<MediaResponse> {
  const pool = getPool()
  
  let query = `
    SELECT m.*, 
           array_agg(
             CASE WHEN t.id IS NOT NULL 
             THEN json_build_object('id', t.id, 'tag_type', t.tag_type, 'tag_value', t.tag_value, 'value', t.tag_value)
             ELSE NULL END
           ) FILTER (WHERE t.id IS NOT NULL) as tags
    FROM hunter_memorial.hunter_media m
    LEFT JOIN hunter_memorial.hunter_tags t ON m.id = t.media_id
  `
  
  const conditions: string[] = []
  const values: any[] = []
  let valueIndex = 1
  
  // Apply filters
  if (filters.search) {
    conditions.push(`(m.filename ILIKE ${valueIndex} OR m.description ILIKE ${valueIndex} OR m.location_name ILIKE ${valueIndex})`)
    values.push(`%${filters.search}%`)
    valueIndex++
  }
  
  if (filters.type) {
    conditions.push(`m.media_type = ${valueIndex}`)
    values.push(filters.type)
    valueIndex++
  }
  
  if (filters.startDate) {
    conditions.push(`m.taken_at >= ${valueIndex}`)
    values.push(filters.startDate)
    valueIndex++
  }
  
  if (filters.endDate) {
    conditions.push(`m.taken_at <= ${valueIndex}`)
    values.push(filters.endDate)
    valueIndex++
  }
  
  if (filters.tags && filters.tags.length > 0) {
    conditions.push(`m.id IN (
      SELECT media_id FROM hunter_memorial.hunter_tags 
      WHERE tag_value = ANY(${valueIndex})
    )`)
    values.push(filters.tags)
    valueIndex++
  }
  
  if (conditions.length > 0) {
    query += ' WHERE ' + conditions.join(' AND ')
  }
  
  query += `
    GROUP BY m.id
    ORDER BY m.taken_at DESC NULLS LAST, m.created_at DESC
  `
  
  // Add limit if specified
  const limit = parseInt(String(filters.limit || 50))
  if (limit > 0) {
    query += ` LIMIT ${valueIndex}`
    values.push(limit)
  }
  
  const result = await pool.query(query, values)
  
  // Get total count
  let countQuery = `SELECT COUNT(*) FROM hunter_memorial.hunter_media m`
  if (conditions.length > 0) {
    countQuery += ' WHERE ' + conditions.join(' AND ')
  }
  
  const countResult = await pool.query(countQuery, values.slice(0, -1)) // Remove limit from count query
  const total = parseInt(countResult.rows[0].count)
  
  return {
    media: result.rows.map(row => ({
      ...row,
      has_location: !!(row.location_lat && row.location_lng)
    })),
    total,
    hasMore: result.rows.length === limit && total > limit,
    filters
  }
}

export async function getMediaById(id: number): Promise<MediaFile | null> {
  const pool = getPool()
  
  const query = `
    SELECT m.*, 
           array_agg(
             CASE WHEN t.id IS NOT NULL 
             THEN json_build_object('id', t.id, 'tag_type', t.tag_type, 'tag_value', t.tag_value, 'value', t.tag_value)
             ELSE NULL END
           ) FILTER (WHERE t.id IS NOT NULL) as tags
    FROM hunter_memorial.hunter_media m
    LEFT JOIN hunter_memorial.hunter_tags t ON m.id = t.media_id
    WHERE m.id = $1
    GROUP BY m.id
  `
  
  const result = await pool.query(query, [id])
  
  if (result.rows.length === 0) {
    return null
  }
  
  const row = result.rows[0]
  return {
    ...row,
    has_location: !!(row.location_lat && row.location_lng)
  }
}

export async function updateMediaFile(id: number, updates: Partial<MediaFile>): Promise<MediaFile | null> {
  const pool = getPool()
  
  const setClause: string[] = []
  const values: any[] = []
  let valueIndex = 1
  
  // Build dynamic update query
  if (updates.description !== undefined) {
    setClause.push(`description = ${valueIndex}`)
    values.push(updates.description)
    valueIndex++
  }
  
  if (updates.location_name !== undefined) {
    setClause.push(`location_name = ${valueIndex}`)
    values.push(updates.location_name)
    valueIndex++
  }
  
  if (updates.location_lat !== undefined) {
    setClause.push(`location_lat = ${valueIndex}`)
    values.push(updates.location_lat)
    valueIndex++
  }
  
  if (updates.location_lng !== undefined) {
    setClause.push(`location_lng = ${valueIndex}`)
    values.push(updates.location_lng)
    valueIndex++
  }
  
  if (setClause.length === 0) {
    return getMediaById(id) // No updates, return current
  }
  
  const query = `
    UPDATE hunter_memorial.hunter_media 
    SET ${setClause.join(', ')}
    WHERE id = ${valueIndex}
    RETURNING *
  `
  
  values.push(id)
  
  const result = await pool.query(query, values)
  
  if (result.rows.length === 0) {
    return null
  }
  
  return getMediaById(id) // Return with tags
}

export async function addMediaTag(mediaId: number, tagType: TagType, tagValue: string): Promise<MediaTag> {
  const pool = getPool()
  
  const query = `
    INSERT INTO hunter_memorial.hunter_tags (media_id, tag_type, tag_value)
    VALUES ($1, $2, $3)
    ON CONFLICT (media_id, tag_type, tag_value) DO NOTHING
    RETURNING *
  `
  
  const result = await pool.query(query, [mediaId, tagType, tagValue.trim().toLowerCase()])
  return result.rows[0]
}

export async function removeMediaTag(tagId: number): Promise<boolean> {
  const pool = getPool()
  
  const query = `DELETE FROM hunter_memorial.hunter_tags WHERE id = $1`
  const result = await pool.query(query, [tagId])
  
  return (result.rowCount ?? 0) > 0
}

export async function getTagSuggestions(tagType?: TagType): Promise<string[]> {
  const pool = getPool()
  
  let query = `
    SELECT DISTINCT tag_value, COUNT(*) as usage_count
    FROM hunter_memorial.hunter_tags
  `
  
  const values: any[] = []
  
  if (tagType) {
    query += ` WHERE tag_type = $1`
    values.push(tagType)
  }
  
  query += ` GROUP BY tag_value ORDER BY usage_count DESC, tag_value ASC LIMIT 50`
  
  const result = await pool.query(query, values)
  return result.rows.map(row => row.tag_value)
}

export async function updateThumbnailPaths(id: number, thumbnails: {
  thumbnail_150?: string
  thumbnail_500?: string
  thumbnail_1200?: string
}): Promise<void> {
  const pool = getPool()
  
  const setClause: string[] = []
  const values: any[] = []
  let valueIndex = 1
  
  if (thumbnails.thumbnail_150) {
    setClause.push(`thumbnail_150 = ${valueIndex}`)
    values.push(thumbnails.thumbnail_150)
    valueIndex++
  }
  
  if (thumbnails.thumbnail_500) {
    setClause.push(`thumbnail_500 = ${valueIndex}`)
    values.push(thumbnails.thumbnail_500)
    valueIndex++
  }
  
  if (thumbnails.thumbnail_1200) {
    setClause.push(`thumbnail_1200 = ${valueIndex}`)
    values.push(thumbnails.thumbnail_1200)
    valueIndex++
  }
  
  if (setClause.length === 0) return
  
  const query = `
    UPDATE hunter_memorial.hunter_media 
    SET ${setClause.join(', ')}
    WHERE id = ${valueIndex}
  `
  
  values.push(id)
  await pool.query(query, values)
}

// File system utilities for integration
export function getMediaStoragePath(): string {
  return process.env.HUNTER_MEDIA_PATH || '/var/hunter-media'
}

export function getThumbnailPath(size: 150 | 500 | 1200): string {
  return `${getMediaStoragePath()}/thumbnails/${size}`
}

export function getOriginalsPath(): string {
  return `${getMediaStoragePath()}/originals`
}

// Authentication functions
export async function verifyFamilyAuth(username: string, password: string): Promise<boolean> {
  // Family admin credentials
  const validUsername = process.env.HUNTER_ADMIN_USER || 'boyboy'
  const validPassword = process.env.HUNTER_ADMIN_PASSWORD || '010918'
  
  return username === validUsername && password === validPassword
}

export function generateAuthToken(): string {
  // Simple token generation - in production use JWT or similar
  const timestamp = Date.now().toString()
  const random = Math.random().toString(36).substring(2)
  return `hunter_${timestamp}_${random}`
}

export function verifyAuthToken(token: string): boolean {
  // Simple token validation - in production validate JWT properly
  if (!token || !token.startsWith('hunter_')) {
    return false
  }
  
  // Extract timestamp from token
  const parts = token.split('_')
  if (parts.length !== 3) return false
  
  const timestamp = parseInt(parts[1])
  if (isNaN(timestamp)) return false
  
  // Token expires after 24 hours
  const expirationTime = 24 * 60 * 60 * 1000
  return (Date.now() - timestamp) < expirationTime
}

// Database class wrapper for API routes
export class HunterMediaDB {
  // Core methods with full names
  static async getMediaFiles(filters: SearchFilters = {}): Promise<MediaResponse> {
    return getMediaFiles(filters)
  }
  
  static async getMediaById(id: number): Promise<MediaFile | null> {
    return getMediaById(id)
  }
  
  static async updateMediaFile(id: number, updates: Partial<MediaFile>): Promise<MediaFile | null> {
    return updateMediaFile(id, updates)
  }
  
  static async saveMediaFile(
    filename: string,
    filePath: string,
    mediaType: 'image' | 'video',
    fileSize: number,
    exifData: ProcessedExifData
  ): Promise<MediaFile> {
    return saveMediaFile(filename, filePath, mediaType, fileSize, exifData)
  }
  
  static async addMediaTag(mediaId: number, tagType: TagType, tagValue: string): Promise<MediaTag> {
    return addMediaTag(mediaId, tagType, tagValue)
  }
  
  static async removeMediaTag(tagId: number): Promise<boolean> {
    return removeMediaTag(tagId)
  }
  
  static async getTagSuggestions(tagType?: TagType): Promise<string[]> {
    return getTagSuggestions(tagType)
  }
  
  static async updateThumbnailPaths(id: number, thumbnails: {
    thumbnail_150?: string
    thumbnail_500?: string
    thumbnail_1200?: string
  }): Promise<void> {
    return updateThumbnailPaths(id, thumbnails)
  }
  
  // Common API route aliases
  static async getMedia(filters: SearchFilters = {}): Promise<MediaResponse> {
    return getMediaFiles(filters)
  }
  
  static async updateMedia(id: number, updates: Partial<MediaFile>): Promise<MediaFile | null> {
    return updateMediaFile(id, updates)
  }
  
  static async saveMedia(
    filename: string,
    filePath: string,
    mediaType: 'image' | 'video',
    fileSize: number,
    exifData: ProcessedExifData
  ): Promise<MediaFile> {
    return saveMediaFile(filename, filePath, mediaType, fileSize, exifData)
  }
  
  static async createMedia(
    filename: string,
    filePath: string,
    mediaType: 'image' | 'video',
    fileSize: number,
    exifData: ProcessedExifData
  ): Promise<MediaFile> {
    return saveMediaFile(filename, filePath, mediaType, fileSize, exifData)
  }
  
  static async addTag(mediaId: number, tagType: TagType, tagValue: string): Promise<MediaTag> {
    return addMediaTag(mediaId, tagType, tagValue)
  }
  
  static async removeTag(tagId: number): Promise<boolean> {
    return removeMediaTag(tagId)
  }
  
  static async getTags(tagType?: TagType): Promise<string[]> {
    return getTagSuggestions(tagType)
  }
  
  static async updateThumbnails(id: number, thumbnails: {
    thumbnail_150?: string
    thumbnail_500?: string
    thumbnail_1200?: string
  }): Promise<void> {
    return updateThumbnailPaths(id, thumbnails)
  }
}